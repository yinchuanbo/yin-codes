<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>07 JavaScript</title>
    <link rel="shortcut icon" href="code.svg" type="image/x-icon" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/editor/editor.main.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./css/edit.css" />
  </head>
  <body>
    <div class="wrapper">
      <div class="wrapper__main">
        <div class="wrapper__main_layout">
          <div class="wrapper__main_layout-content">
            <div class="wrapper-left">
              <div class="wrapper-left_bar">
                <div class="wrapper-left_bar-home" onclick="location.href='/'">
                  <svg
                    t="1724509753486"
                    class="icon"
                    viewBox="0 0 1024 1024"
                    version="1.1"
                    xmlns="http://www.w3.org/2000/svg"
                    p-id="13815"
                    width="200"
                    height="200"
                  >
                    <path
                      d="M579.264 106.88l394.986667 353.557333a21.205333 21.205333 0 0 1-14.144 37.034667h-78.933334v356.330667A84.864 84.864 0 0 1 796.309333 938.666667H249.024a84.864 84.864 0 0 1-84.864-84.864V497.472h-78.933333a21.205333 21.205333 0 0 1-14.144-37.034667L466.069333 106.88a84.864 84.864 0 0 1 113.194667 0z m-77.824 87.637333l-247.658667 221.653334v413.034666c0 11.733333 9.514667 21.226667 21.226667 21.226667h495.317333c11.733333 0 21.226667-9.514667 21.226667-21.226667V416.149333l-247.68-221.653333a31.829333 31.829333 0 0 0-42.432 0z m156.373333 479.424a44.117333 44.117333 0 0 1 0 88.234667h-270.293333a44.117333 44.117333 0 0 1 0-88.234667h270.293333z"
                      fill="currentColor"
                      p-id="13816"
                    ></path>
                  </svg>
                </div>

                <div
                  class="wrapper-left_bar-preview"
                  onclick="window.open('./articles/07 JavaScript')"
                >
                  <svg
                    t="1724509963924"
                    class="icon"
                    viewBox="0 0 1024 1024"
                    version="1.1"
                    xmlns="http://www.w3.org/2000/svg"
                    p-id="19549"
                    width="200"
                    height="200"
                  >
                    <path
                      d="M170.666667 640a42.666667 42.666667 0 0 1 42.666666 42.666667v128h128a42.666667 42.666667 0 0 1 0 85.333333H213.333333a85.333333 85.333333 0 0 1-85.333333-85.333333v-128a42.666667 42.666667 0 0 1 42.666667-42.666667z m682.666666 0a42.666667 42.666667 0 0 1 42.666667 42.666667v128a85.333333 85.333333 0 0 1-85.333333 85.333333h-128a42.666667 42.666667 0 0 1 0-85.333333h128v-128a42.666667 42.666667 0 0 1 42.666666-42.666667z m-213.333333-298.666667a85.333333 85.333333 0 0 1 85.333333 85.333334v170.666666a85.333333 85.333333 0 0 1-85.333333 85.333334H384a85.333333 85.333333 0 0 1-85.333333-85.333334v-170.666666a85.333333 85.333333 0 0 1 85.333333-85.333334h256z m0 85.333334H384v170.666666h256v-170.666666z m170.666667-298.666667a85.333333 85.333333 0 0 1 85.333333 85.333333v128a42.666667 42.666667 0 0 1-85.333333 0V213.333333h-128a42.666667 42.666667 0 0 1 0-85.333333h128zM341.333333 128a42.666667 42.666667 0 1 1 0 85.333333H213.333333v128a42.666667 42.666667 0 1 1-85.333333 0V213.333333a85.333333 85.333333 0 0 1 85.333333-85.333333h128z"
                      fill="currentColor"
                      p-id="19550"
                    ></path>
                  </svg>
                </div>
              </div>
              <ul><li data-id="13" data-path="01 使用 JS 向现有 SVG 中添加元素.md">01 使用 JS 向现有 SVG 中添加元素.md</li><li data-id="14" data-path="02 速通 JS 性能优化.md">02 速通 JS 性能优化.md</li><li data-id="15" data-path="03 JS 单行代码集.md">03 JS 单行代码集.md</li><li data-id="16" data-path="04 5 种 JS 模式.md">04 5 种 JS 模式.md</li><li data-id="17" data-path="05 高效检查 JS 对象中的键是否存在.md">05 高效检查 JS 对象中的键是否存在.md</li><li data-id="18" data-path="06 7 种位运算符的神奇用法.md">06 7 种位运算符的神奇用法.md</li></ul>
            </div>
            <div class="wrapper-content"></div>
          </div>
        </div>
      </div>
    </div>
    <pre id="pre" style="display: none">
      {
  &#34;01 使用 JS 向现有 SVG 中添加元素.md&#34;: &#34;&lt;h1&gt;如何使用 JavaScript 向现有 SVG 中添加元素？&lt;/h1&gt;\n&lt;h3&gt;动态向 SVG 中添加元素的实际应用场景&lt;/h3&gt;\n&lt;p&gt;假设我们正在开发一个数据可视化的应用程序，其中的图表是用 SVG 绘制的。现在我们需要根据用户的操作动态地在现有的 SVG 图表中添加新的数据点或者线段。在这种情况下，我们就需要通过 JavaScript 来操作 SVG。&lt;/p&gt;\n&lt;h3&gt;具体操作步骤&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;选择 SVG 元素：首先，我们需要通过 JavaScript 找到页面上已经存在的 SVG 元素。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;创建新元素并指定命名空间：SVG 元素与普通的 HTML 元素不同，它们有特定的命名空间。因此，在创建新的 SVG 元素时，我们必须指定这个命名空间。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;设置属性：新创建的 SVG 元素需要设置一些属性，比如路径、颜色、线宽等。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;将新元素添加到 SVG 中：最后一步就是将新创建的 SVG 元素添加到我们选中的 SVG 元素中，使其显示在页面上。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3&gt;代码示例&lt;/h3&gt;\n&lt;p&gt;假设我们有以下的 HTML 结构：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;svg width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;&amp;gt;&amp;lt;/svg&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们希望在这个空的 SVG 中动态添加一条直线。可以使用以下 JavaScript 代码实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 选择SVG元素\nconst svg = document.querySelector(&amp;quot;svg&amp;quot;);\n\n// 创建一个新的line元素，并指定命名空间\nconst newLine = document.createElementNS(&amp;quot;http://www.w3.org/2000/svg&amp;quot;, &amp;quot;line&amp;quot;);\n\n// 设置line元素的属性，起点为(10,10)，终点为(90,90)\nnewLine.setAttribute(&amp;quot;x1&amp;quot;, &amp;quot;10&amp;quot;);\nnewLine.setAttribute(&amp;quot;y1&amp;quot;, &amp;quot;10&amp;quot;);\nnewLine.setAttribute(&amp;quot;x2&amp;quot;, &amp;quot;90&amp;quot;);\nnewLine.setAttribute(&amp;quot;y2&amp;quot;, &amp;quot;90&amp;quot;);\n\n// 设置线条的颜色和宽度\nnewLine.style.stroke = &amp;quot;blue&amp;quot;;\nnewLine.style.strokeWidth = &amp;quot;2px&amp;quot;;\n\n// 将新创建的line元素添加到SVG中\nsvg.appendChild(newLine);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这段代码会在页面上显示一条从 &lt;code&gt;(10,10)&lt;/code&gt; 到 &lt;code&gt;(90,90)&lt;/code&gt; 的蓝色线条。我们通过 &lt;code&gt;document.querySelector&lt;/code&gt; 选择了 SVG 元素，然后使用 &lt;code&gt;document.createElementNS&lt;/code&gt; 创建了一个新的 line 元素，并通过设置属性来定义这条线的位置和样式，最后通过 appendChild 将其添加到 SVG 中。&lt;/p&gt;\n&#34;,
  &#34;02 速通 JS 性能优化.md&#34;: &#34;&lt;h1&gt;速通 JS 性能优化&lt;/h1&gt;\n&lt;h3&gt;1. 内存管理方案&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;1.1 全局变量导致内存泄漏问题&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;使用全局变量可能会导致内存泄漏，因为它们在程序终止之前不会自动被垃圾回收。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 具有全局变量的内存泄漏示例\nlet globalArray = [];\nfunction addToGlobalArray(item) {\n  globalArray.push(item);\n}\n\n// 使用局部变量修复这个问题\nfunction manageArray() {\n  let localArray = [];\n  function addToArray(item) {\n    localArray.push(item);\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;1.2 闭包引发的内存泄漏&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;即使外部函数已经返回，闭包仍可以保留对变量的引用，如果使用不当，可能会导致内存泄漏&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 闭包导致内存泄漏的场景\nfunction outerFunction() {\n  let largeArray = new Array(1000000).fill(&amp;quot;data&amp;quot;);\n  return function innerFunction() {\n    console.log(largeArray.length);\n  };\n}\nconst inner = outerFunction();\ninner();\n\n// 通过显示的清除方案，解决内存泄漏的问题\nfunction outerFunction() {\n  let largeArray = new Array(1000000).fill(&amp;quot;data&amp;quot;);\n  return function innerFunction() {\n    console.log(largeArray.length);\n    largeArray = null; // 显示清除\n  };\n}\nconst inner = outerFunction();\ninner();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;1.3 事件监听导致内存泄漏问题&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;当不再需要事件监听器时未能删除它们可能会导致内存泄漏&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 事件监听器的可能会导致内存泄漏\nfunction addEventListenerExample() {\n  document.querySelector(&amp;quot;button&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, function () {\n    console.log(&amp;quot;Button clicked&amp;quot;);\n  });\n}\n\n// 手动清除监听器\nfunction addEventListenerExample() {\n  const button = document.querySelector(&amp;quot;button&amp;quot;);\n  const clickHandler = function () {\n    console.log(&amp;quot;Button clicked&amp;quot;);\n  };\n  button.addEventListener(&amp;quot;click&amp;quot;, clickHandler); // 删除监听\n  button.removeEventListener(&amp;quot;click&amp;quot;, clickHandler);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;1.4 DOM 节点导致的内存泄漏&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;引用的已经删除的 DOM 节点可能会导致内存泄漏。当删除节点时，需要清理 DOM 引用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// DON 节点的引用\nlet element = document.createElement(&amp;quot;div&amp;quot;);\ndocument.body.appendChild(element);\ndocument.body.removeChild(element); // DOM 节点被删除\n// 手动清理引用\nelement = null;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;2. 基于 Web Worker 进行性能提升&lt;/h3&gt;\n&lt;h3&gt;3. 数据结构提升 JS 性能&lt;/h3&gt;\n&lt;p&gt;选择正确的数据结构会显著影响 JavaScript 应用程序的性能。高效的数据结构可以提高搜索、排序和操作数据等操作的速度和内存使用率&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 基于 Set 构建唯一值的集合\nconst uniqueValues = new Set([1, 2, 3, 4, 5, 5, 6]);\nuniqueValues.add(7);\nuniqueValues.delete(3);\nconsole.log(uniqueValues.has(2)); // true\nconsole.log(uniqueValues.size); // 6\n// 基于 Map 构建 key-value 结构\nconst map = new Map();\nmap.set(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;);\nmap.set(&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;);\nconsole.log(map.get(&amp;quot;key1&amp;quot;)); // &amp;#39;value1&amp;#39;\nmap.delete(&amp;quot;key2&amp;quot;);\nconsole.log(map.size); // 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;4. 基于 WebAssembly 处理密集任务&lt;/h3&gt;\n&lt;p&gt;WebAssembly (Wasm) 是一种二进制指令格式（文档：&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts%EF%BC%89%EF%BC%8C%E5%8F%AF%E5%9C%A8\&#34;&gt;https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts），可在&lt;/a&gt; Web 上实现代码的高性能执行。它允许开发人员使用 C、C++ 和 Rust 等语言编写性能关键型代码，并与 JavaScript 一起运行。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rs\&#34;&gt;// src/lib.rs\n#[wasm_bindgen]\npub fn fibonacci(n: u32) -&amp;gt; u32 {\n    match n {\n        0 =&amp;gt; 0,\n        1 =&amp;gt; 1,\n        _ =&amp;gt; fibonacci(n - 1) + fibonacci(n - 2),\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;//加载和执行 WebAssembly 模块的 js 代码\nfetch(&amp;quot;fibonacci.wasm&amp;quot;)\n  .then((response) =&amp;gt; response.arrayBuffer())\n  .then((bytes) =&amp;gt; WebAssembly.instantiate(bytes))\n  .then((result) =&amp;gt; {\n    const fibonacci = result.instance.exports.fibonacci;\n    console.log(fibonacci(10)); // Output: 55\n  });\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,
  &#34;03 JS 单行代码集.md&#34;: &#34;&lt;h1&gt;25 个杀手级 JavaScript 单行代码&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;将内容复制到剪贴板为了提高网站的用户体验，我们经常需要将内容复制到剪贴板，以便用户将其粘贴到指定位置。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const copyToClipboard = (content) =&amp;gt; navigator.clipboard.writeText(content);\ncopyToClipboard(&amp;quot;Hello fatfish&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;获取鼠标选择&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;我们需要获取用户选择的内容&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const getSelectedText = () =&amp;gt; window.getSelection().toString();\ngetSelectedText();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;打乱数组&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const shuffleArray = (array) =&amp;gt; array.sort(() =&amp;gt; Math.random() - 0.5);\nshuffleArray([1, 2, 3, 4, -1, 0]); // [3, 1, 0, 2, 4, -1]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;将 rgba 转换为十六进制&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;我们可以将 rgba 和十六进制颜色值相互转换。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const rgbaToHex = (r, g, b) =&amp;gt;\n  &amp;quot;#&amp;quot; +\n  [r, g, b].map((num) =&amp;gt; parseInt(num).toString(16).padStart(2, &amp;quot;0&amp;quot;)).join(&amp;quot;&amp;quot;);\nrgbaToHex(0, 0, 0); // #000000rgbaToHex(255, 0, 127) //#ff007f\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;5\&#34;&gt;\n&lt;li&gt;将十六进制转换为 rgba&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const hexToRgba = hex =&amp;gt; {  const [r, g, b] = hex.match(/\\w\\w/g).map(val =&amp;gt; parseInt(val, 16))  return `rgba(${r}, ${g}, ${b}, 1)`;}\nhexToRgba(&amp;#39;#000000&amp;#39;) // rgba(0, 0, 0, 1)hexToRgba(&amp;#39;#ff007f&amp;#39;) // rgba(255, 0, 127, 1)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;6\&#34;&gt;\n&lt;li&gt;获取多个数字的平均值&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;使用 reduce 我们可以非常方便地获取一组数组的平均值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const average = (...args) =&amp;gt; args.reduce((a, b) =&amp;gt; a + b, 0) / args.length;\naverage(0, 1, 2, -1, 9, 10); // 3.5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;7\&#34;&gt;\n&lt;li&gt;检查数字是偶数还是奇数&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;你如何判断数字是奇数还是偶数？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const isEven = (num) =&amp;gt; num % 2 === 0;\nisEven(2); // trueisEven(1) // false\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;8\&#34;&gt;\n&lt;li&gt;删除数组中的重复元素&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;要删除数组中的重复元素，使用 Set 会变得非常容易。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const uniqueArray = (arr) =&amp;gt; [...new Set(arr)];\nuniqueArray([1, 1, 2, 3, 4, 5, -1, 0]); // [1, 2, 3, 4, 5, -1, 0]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;9\&#34;&gt;\n&lt;li&gt;检查对象是否为空对象&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const isEmpty = (obj) =&amp;gt;\n  Reflect.ownKeys(obj).length === 0 &amp;amp;&amp;amp; obj.constructor === Object;\nisEmpty({}); // trueisEmpty({ name: &amp;#39;fatfish&amp;#39; }) // false\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;10\&#34;&gt;\n&lt;li&gt;反转字符串&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const reverseStr = (str) =&amp;gt; str.split(&amp;quot;&amp;quot;).reverse().join(&amp;quot;&amp;quot;);\nreverseStr(&amp;quot;fatfish&amp;quot;); // hsiftaf\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;11\&#34;&gt;\n&lt;li&gt;计算两个日期之间的间隔&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const dayDiff = (d1, d2) =&amp;gt;\n  Math.ceil(Math.abs(d1.getTime() - d2.getTime()) / 86400000);\ndayDiff(new Date(&amp;quot;2023-06-23&amp;quot;), new Date(&amp;quot;1997-05-31&amp;quot;)); // 9519\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;12\&#34;&gt;\n&lt;li&gt;找出日期所在的年份&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const dayInYear = (d) =&amp;gt;\n  Math.floor((d - new Date(d.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);\ndayInYear(new Date(&amp;quot;2023/06/23&amp;quot;)); // 174\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;13\&#34;&gt;\n&lt;li&gt;将字符串的首字母大写&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const capitalize = (str) =&amp;gt; str.charAt(0).toUpperCase() + str.slice(1);\ncapitalize(&amp;quot;hello fatfish&amp;quot;); // Hello fatfish\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;14\&#34;&gt;\n&lt;li&gt;生成指定长度的随机字符串&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const generateRandomString = (length) =&amp;gt;\n  [...Array(length)].map(() =&amp;gt; Math.random().toString(36)[2]).join(&amp;quot;&amp;quot;);\ngenerateRandomString(12); // cysw0gfljoyxgenerateRandomString(12) // uoqaugnm8r4s\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;15\&#34;&gt;\n&lt;li&gt;获取两个整数之间的随机整数&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const random = (min, max) =&amp;gt; Math.floor(Math.random() * (max - min + 1) + min);\nrandom(1, 100); // 27\nrandom(1, 100); // 84\nrandom(1, 100); // 55\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;16\&#34;&gt;\n&lt;li&gt;指定数字四舍五入&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const round = (n, d) =&amp;gt; Number(Math.round(n + &amp;quot;e&amp;quot; + d) + &amp;quot;e-&amp;quot; + d);\nround(3.1415926, 3); //3.142\nround(3.1415926, 1); //3.1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;17\&#34;&gt;\n&lt;li&gt;清除所有 cookie&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const clearCookies = document.cookie\n  .split(&amp;quot;;&amp;quot;)\n  .forEach(\n    (cookie) =&amp;gt;\n      (document.cookie = cookie\n        .replace(/^ +/, &amp;quot;&amp;quot;)\n        .replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`))\n  );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;18\&#34;&gt;\n&lt;li&gt;检测是否为暗模式&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const isDarkMode =\n  window.matchMedia &amp;amp;&amp;amp;\n  window.matchMedia(&amp;quot;(prefers-color-scheme: dark)&amp;quot;).matches;\nconsole.log(isDarkMode);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;19\&#34;&gt;\n&lt;li&gt;滚动到页面顶部&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const goToTop = () =&amp;gt; window.scrollTo(0, 0);\ngoToTop();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;20\&#34;&gt;\n&lt;li&gt;确定是否为 Apple 设备&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const isAppleDevice = () =&amp;gt; /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nisAppleDevice();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;21\&#34;&gt;\n&lt;li&gt;随机布尔值&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const randomBoolean = () =&amp;gt; Math.random() &amp;gt;= 0.5;\nrandomBoolean();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;22\&#34;&gt;\n&lt;li&gt;获取变量的类型&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const typeOf = (obj) =&amp;gt;\n  Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\ntypeOf(&amp;quot;&amp;quot;); // string\ntypeOf(0); // number\ntypeOf(); // undefined\ntypeOf(null); // null\ntypeOf({}); // object\ntypeOf([]); // array\ntypeOf(0); // number\ntypeOf(() =&amp;gt; {}); // function\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;23\&#34;&gt;\n&lt;li&gt;确定当前选项卡是否处于活动状态&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const checkTabInView = () =&amp;gt; !document.hidden;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;24\&#34;&gt;\n&lt;li&gt;检查元素是否处于焦点&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const isFocus = (ele) =&amp;gt; ele === document.activeElement;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;25\&#34;&gt;\n&lt;li&gt;随机 IP&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const generateRandomIP = () =&amp;gt; {\n  return Array.from({ length: 4 }, () =&amp;gt; Math.floor(Math.random() * 256)).join(\n    &amp;quot;.&amp;quot;\n  );\n};\ngenerateRandomIP(); // 220.187.184.113\ngenerateRandomIP(); // 254.24.179.151\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,
  &#34;04 5 种 JS 模式.md&#34;: &#34;&lt;h1&gt;5 种 JavaScript 模式可提高代码质量和可维护性&lt;/h1&gt;\n&lt;h2&gt;模块模式&lt;/h2&gt;\n&lt;p&gt;模块模式是 JavaScript 中最常见和最有用的设计模式之一。它有助于创建封装和可重用的代码。通过使用模块模式，您可以保持变量和函数的私有性，仅公开代码中必要的部分。此模式对于维护干净的全局命名空间和避免名称冲突至关重要。&lt;/p&gt;\n&lt;p&gt;下面是模块模式的简单示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const myModule = (function () {\n  // Private variables and functions\n  let privateVar = &amp;quot;I am private&amp;quot;;\n  function privateFunction() {\n    console.log(privateVar);\n  } // Public API\n\n  return {\n    publicVar: &amp;quot;I am public&amp;quot;,\n    publicFunction: function () {\n      privateFunction();\n    },\n  };\n})();\n\nconsole.log(myModule.publicVar); // I am public\nmyModule.publicFunction(); // I am privat\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;：保持代码的模块化和封装，从而降低变量冲突的风险。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;可重用&lt;/strong&gt;：创建可重用的代码，这些代码可以轻松导入并在应用程序的不同部分使用。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：通过分离关注点，使代码更易于维护和理解。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;实际应用场景&lt;/strong&gt;：&lt;/p&gt;\n&lt;p&gt;模块模式通常用于 JavaScript 库和框架中，用于封装代码并公开干净的 API。例如，在 Web 应用程序中，您可以使用模块模式来管理不同的组件，例如用户身份验证、数据获取和 UI 呈现。&lt;/p&gt;\n&lt;h2&gt;单例模式&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;为什么重要：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;单例模式确保一个类只有一个实例，并提供对它的全局访问点。当您需要管理共享资源（如数据库连接或配置文件）时，这尤其有用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const Singleton = (function () {\n  let instance;\n\n  function createInstance() {\n    const object = new Object(&amp;quot;I am the instance&amp;quot;);\n    return object;\n  }\n\n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;受控访问&lt;/strong&gt;：确保对实例的单点访问。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;减少内存占用&lt;/strong&gt;：由于仅存在一个实例，因此可以帮助减少内存使用。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;全局访问&lt;/strong&gt;：提供实例的全局访问点，使其易于在整个应用程序中使用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;实际应用场景：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;单例模式通常用于日志记录、缓存和数据库连接池。例如，在 Node.js 应用程序中，可以使用单一实例来管理数据库连接，以确保应用程序的所有部分都使用相同的连接实例。&lt;/p&gt;\n&lt;h2&gt;观察者模式&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;为什么重要：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;观察者模式是一种行为设计模式，其中对象（称为主体）维护一个依赖对象列表（称为观察者），并通知它们任何状态更改。此模式非常适合实现事件处理系统。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n    this.observers = this.observers.filter((obs) =&amp;gt; obs !== observer);\n  }\n\n  notify(data) {\n    this.observers.forEach((observer) =&amp;gt; observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log(&amp;quot;Observer received:&amp;quot;, data);\n  }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify(&amp;quot;Hello Observers!&amp;quot;); // Observer received: Hello Observers!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;松耦合&lt;/strong&gt;：促进被摄体和观察者之间的松耦合。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;动态关系&lt;/strong&gt;：允许动态注册和删除观察者。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;可重用性&lt;/strong&gt;：便于独立地重用和扩展主体和观察者。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;实际应用场景：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;观察者模式广泛用于事件驱动的系统，如用户界面。例如，在聊天应用程序中，您可以使用观察者模式来通知用户新消息或状态更新。&lt;/p&gt;\n&lt;h2&gt;工厂模式&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;为什么重要：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;工厂模式是一种创建性设计模式，它提供了一种创建对象的方法，而无需指定将要创建的确切对象类别。当您有一个通用的接口但不同的实现时，此模式非常有用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} says Woof!`);\n  }\n}\n\nclass Cat {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} says Meow!`);\n  }\n}\n\nclass AnimalFactory {\n  static createAnimal(type, name) {\n    switch (type) {\n      case &amp;quot;dog&amp;quot;:\n        return new Dog(name);\n      case &amp;quot;cat&amp;quot;:\n        return new Cat(name);\n      default:\n        throw new Error(&amp;quot;Invalid animal type&amp;quot;);\n    }\n  }\n}\n\nconst myDog = AnimalFactory.createAnimal(&amp;quot;dog&amp;quot;, &amp;quot;Buddy&amp;quot;);\nmyDog.speak(); // Buddy says Woof!\n\nconst myCat = AnimalFactory.createAnimal(&amp;quot;cat&amp;quot;, &amp;quot;Kitty&amp;quot;);\nmyCat.speak(); // Kitty says Meow!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;：封装对象创建过程，使其更易于管理。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;解耦&lt;/strong&gt;：将客户端代码与用于创建对象的特定类解耦。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：无需更改客户端代码即可轻松添加新类型的对象。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;实际应用场景：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;工厂模式通常用于框架和库中，用于创建对象。例如，在 Web 应用程序中，您可以使用工厂根据配置创建不同类型的表单输入。&lt;/p&gt;\n&lt;h2&gt;策略模式&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;为什么重要：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;策略模式是一种行为设计模式，允许您定义一系列算法，封装每个算法，并使它们可互换。此模式对于实现算法的不同变体非常有用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class Context {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeStrategy(a, b) {\n    return this.strategy.execute(a, b);\n  }\n}\n\nclass AddStrategy {\n  execute(a, b) {\n    return a + b;\n  }\n}\n\nclass SubtractStrategy {\n  execute(a, b) {\n    return a - b;\n  }\n}\n\nclass MultiplyStrategy {\n  execute(a, b) {\n    return a * b;\n  }\n}\n\nconst context = new Context(new AddStrategy());\nconsole.log(context.executeStrategy(5, 3)); // 8\n\ncontext.strategy = new SubtractStrategy();\nconsole.log(context.executeStrategy(5, 3)); // 2\n\ncontext.strategy = new MultiplyStrategy();\nconsole.log(context.executeStrategy(5, 3)); // 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：允许您轻松地在不同算法之间切换。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;：对每个算法进行封装，使代码更加模块化，更易于维护。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：无需更改客户端代码即可轻松添加新策略。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;实际应用场景：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;策略模式通常用于排序算法、验证机制和支付处理系统。例如，在电子商务应用程序中，您可以对信用卡、PayPal 和其他付款方式使用不同的付款策略。&lt;/p&gt;\n&#34;,
  &#34;05 高效检查 JS 对象中的键是否存在.md&#34;: &#34;&lt;h1&gt;如何高效检查 JavaScript 对象中的键是否存在&lt;/h1&gt;\n&lt;h2&gt;问题背景&lt;/h2&gt;\n&lt;p&gt;假设我们有一个简单的对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const user = {\n  name: &amp;quot;John&amp;quot;,\n  age: 30,\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们想在访问 &lt;code&gt;name&lt;/code&gt; 键之前检查它是否存在：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (user.name) {\n  console.log(user.name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个方法表面上看没问题，但如果 &lt;code&gt;name&lt;/code&gt; 键存在但值是 &lt;code&gt;undefined&lt;/code&gt; 会怎样呢？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const user = {\n  name: undefined,\n};\n\nif (user.name) {\n  // 这段代码不会执行！\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;直接访问一个不存在的键会返回 &lt;code&gt;undefined&lt;/code&gt;，但是访问值为 &lt;code&gt;undefined&lt;/code&gt; 的键也是返回 &lt;code&gt;undefined&lt;/code&gt;。所以我们不能依赖直接键访问来检查键是否存在。&lt;/p&gt;\n&lt;h2&gt;使用 typeof&lt;/h2&gt;\n&lt;p&gt;一种常见的方法是使用 &lt;code&gt;typeof&lt;/code&gt; 来检查类型：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (typeof user.name !== &amp;quot;undefined&amp;quot;) {\n  console.log(user.name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt; 会对不存在的键返回 &lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;，对存在的键返回其它类型，如 &lt;code&gt;&amp;quot;string&amp;quot;&lt;/code&gt;。然而，这种方法有几个缺点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;需要额外的操作（&lt;code&gt;typeof&lt;/code&gt;）而不是直接比较&lt;/li&gt;\n&lt;li&gt;比较冗长且需要否定检查（&lt;code&gt;!==&lt;/code&gt;）&lt;/li&gt;\n&lt;li&gt;可读性不如其他方法&lt;/li&gt;\n&lt;li&gt;容易拼写错误 &lt;code&gt;&amp;#39;undefined&amp;#39;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;使用 in 操作符&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;in&lt;/code&gt; 操作符允许我们检查键是否存在于对象中：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (&amp;quot;name&amp;quot; in user) {\n  console.log(user.name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种方法比 &lt;code&gt;typeof&lt;/code&gt; 更简洁：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;简单且可读&lt;/li&gt;\n&lt;li&gt;内置语言特性，专为此设计&lt;/li&gt;\n&lt;li&gt;对所有值都有效，包括 &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;但是，&lt;code&gt;in&lt;/code&gt; 操作符也会检查对象的原型链。因此它对原型链上存在的键也会返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;\n&lt;h2&gt;使用 hasOwnProperty&lt;/h2&gt;\n&lt;p&gt;要仅检查对象自身的键，可以使用 &lt;code&gt;hasOwnProperty&lt;/code&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (user.hasOwnProperty(&amp;quot;name&amp;quot;)) {\n  console.log(user.name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种方法只会返回对象自身拥有的键，而不会检查继承的属性：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;只检查自身键，不包括继承的&lt;/li&gt;\n&lt;li&gt;方法名清晰，容易理解&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;缺点是 &lt;code&gt;hasOwnProperty&lt;/code&gt; 需要方法调用，在性能关键的代码中可能会有影响。&lt;/p&gt;\n&lt;h2&gt;性能比较&lt;/h2&gt;\n&lt;p&gt;哪种方法最快呢？以下是直接键访问 &lt;code&gt;in&lt;/code&gt;、&lt;code&gt;hasOwnProperty&lt;/code&gt; 和 &lt;code&gt;typeof&lt;/code&gt; 的简单性能比较：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const user = {\n  name: &amp;quot;John&amp;quot;,\n};\n\nlet key = &amp;quot;name&amp;quot;;\n\nfunction directAccess() {\n  return user[key] !== undefined;\n}\n\nfunction inOperator() {\n  return key in user;\n}\n\nfunction hasOwnProperty() {\n  return user.hasOwnProperty(key);\n}\n\nfunction typeofCheck() {\n  return typeof user[key] !== &amp;quot;undefined&amp;quot;;\n}\n\nfunction objectKeysCheck() {\n  return Object.keys(user).includes(key);\n}\n\n// 运行每个函数100万次\nlet start = performance.now();\nfor (let i = 0; i &amp;lt; 1000000; i++) {\n  directAccess();\n}\nconsole.log(`directAccess took ${performance.now() - start} ms`);\n\nstart = performance.now();\nfor (let i = 0; i &amp;lt; 1000000; i++) {\n  inOperator();\n}\nconsole.log(`inOperator took ${performance.now() - start} ms`);\n\nstart = performance.now();\nfor (let i = 0; i &amp;lt; 1000000; i++) {\n  hasOwnProperty();\n}\nconsole.log(`hasOwnProperty took ${performance.now() - start} ms`);\n\nstart = performance.now();\nfor (let i = 0; i &amp;lt; 1000000; i++) {\n  typeofCheck();\n}\nconsole.log(`typeofCheck took ${performance.now() - start} ms`);\n\nstart = performance.now();\nfor (let i = 0; i &amp;lt; 1000000; i++) {\n  objectKeysCheck();\n}\nconsole.log(`objectKeysCheck took ${performance.now() - start} ms`);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果如下（ 测试机器：apple m1 ,内存 16G）：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;directAccess 耗时 1.59 毫秒&lt;/li&gt;\n&lt;li&gt;inOperator 耗时 0.97 毫秒（注：inOperator 和 typeofCheck 有时会比较接近）&lt;/li&gt;\n&lt;li&gt;hasOwnProperty 耗时 4.74 毫秒&lt;/li&gt;\n&lt;li&gt;typeofCheck 耗时 1.16  毫秒&lt;/li&gt;\n&lt;li&gt;Object.keys()耗时  8.48  毫秒&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如上所示，inOperator 运算显著快于其他方法。&lt;/p&gt;\n&lt;h2&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;直接键访问较快且易读但无法处理&lt;code&gt;undefined&lt;/code&gt;值&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;in&lt;/code&gt;操作符最快但能处理所有值，包括&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;较慢但只检查对象自身的键&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;typeof&lt;/code&gt;速度较快但需要冗长的否定检查&lt;/li&gt;\n&lt;li&gt;Object.keys()方法直观，但速度最慢&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在大多数情况下，&lt;code&gt;in&lt;/code&gt;操作符在可读性和性能之间提供了最佳平衡。只有在需要排除继承键时才使用&lt;code&gt;hasOwnProperty&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;理解这些不同方法的细微差别是检查 JavaScript 键的关键。根据具体需求选择合适的工具，除非性能至关重要，否则应优先考虑可读性。&lt;/p&gt;\n&#34;,
  &#34;06 7 种位运算符的神奇用法.md&#34;: &#34;&lt;h1&gt;7 种 JavaScript 中位运算符的神奇用法&lt;/h1&gt;\n&lt;p&gt;JavaScript 与许多其他编程语言不同，JavaScript 没有定义不同类型的数字，如整数、短整型、长整型、浮点型等。&lt;/p&gt;\n&lt;p&gt;整数精度（不带小数点或指数表示法）最多为 15 位。小数精度的最大位数为 17 位，但浮点运算并不总是 100% 准确。&lt;/p&gt;\n&lt;p&gt;位运算直接计算二进制位，位运算直接处理每个位。它是一种非常低级的操作。优点是速度极快，但缺点是非常不直观，在很多场合不能使用。&lt;/p&gt;\n&lt;p&gt;位运算只对整数起作用。如果操作数不是整数，则在运行前会自动转换为整数。&lt;/p&gt;\n&lt;p&gt;在 JavaScript 内部，值是以 64 位浮点数的形式存储的，但是进行位运算时，是以 32 位有符号整数进行运算的，返回值也是 32 位有符号整数。&lt;/p&gt;\n&lt;h2&gt;JS 中常用的 7 个位运算符&lt;/h2&gt;\n&lt;h3&gt;1. 按位与（AND）&amp;amp;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 将二进制数中相应的位按照特定的方式组合并运算，如果相应位全为 1，结果为 1，如果任意位为 0，结果为 0。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// The binary representation of 3 is: 00000000 00000000 00000000 00000011\n// -----------------------------\n// The binary representation of 1 is: 00000000 00000000 00000000 00000001\nconsole.log(1 &amp;amp; 3); // 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;2. 按位或（OR）|&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;|&lt;/code&gt; 该运算符与 &lt;code&gt;&amp;amp;&lt;/code&gt; 的区别在于，若任意一个操作数在相应位为 1，则结果为 1。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// The binary representation of 3 is: 00000000 00000000 00000000 00000011\n// -----------------------------\n// The binary representation of 3 is: 00000000 00000000 00000000 00000011\nconsole.log(1 | 3); // 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;3. 按位异或（XOR）^&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 如果两个操作数位对应只有一个 1，则结果为 1，其他都为 0。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// The binary representation of 3 is: 00000000 00000000 00000000 00000011\n// -----------------------------\n// The binary representation of 2 is: 00000000 00000000 00000000 00000010\nconsole.log(1 ^ 3); // 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;4. 按位非（NOT）~&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;~&lt;/code&gt; 该运算符是将位取反，1 变成 0，0 变成 1，也就是求二进制的补码。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// The binary representation of 3 is: 00000000 00000000 00000000 00000011\n// -----------------------------\n// 1&amp;#39;s inverse binary representation: 11111111 11111111 11111111 11111110\n// Since the first bit (sign bit) is 1, this number is a negative number. JavaScript internally uses complement code to represent negative numbers, that is, you need to subtract 1 from this number, take the inverse again, and then add a negative sign to get the decimal value corresponding to the negative number.\n// -----------------------------\n// The inverse of 1 minus 1: 11111111 11111111 11111111 11111101\n// Negative code: 00000000 00000000 00000000 00000010\n// Represented as decimal plus minus sign: -2\nconsole.log(~1); // -2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;简单记忆：一个数和它自身的取反值相加等于-1。&lt;/p&gt;\n&lt;h3&gt;5. 左移 &amp;lt;&amp;lt;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符将指定值的二进制数的所有位向左移动指定的次数。&lt;/p&gt;\n&lt;p&gt;移动规则：丢弃高位，用 0 填充低位，即把所有数按二进制形式向左移动相应的位数，去掉高位（丢弃），去掉低位。&lt;/p&gt;\n&lt;p&gt;空白处用零填充。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// -----------------------------\n// The binary representation of 2 is: 00000000 00000000 00000000 00000010\nconsole.log(1 &amp;lt;&amp;lt; 1); // 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;6. 有符号右移 &amp;gt;&amp;gt;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 此运算符将指定操作数的位向右移动指定的位数。向右移出的位将被丢弃，最左边的位将被复制以填充左侧。由于新的最左边的位始终与之前相同，因此符号位不会改变。这就是为什么它被称为“符号通信”。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// The binary representation of 1 is: 00000000 00000000 00000000 00000001\n// -----------------------------\n// The binary representation of 0 is: 00000000 00000000 00000000 00000000\nconsole.log(1 &amp;gt;&amp;gt; 1); // 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;7. 无符号右移 &amp;gt;&amp;gt;&amp;gt;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 该运算符将第一个操作数向右移动指定的位数。向右移动的位被丢弃，左侧用 0 填充。由于符号位变为 0，因此，结果始终为非负数。（译注：即使向右移动 0 位，结果也是非负数。）&lt;/p&gt;\n&lt;p&gt;对于非负数，有符号和无符号右移总是返回相同的结果。例如，&lt;code&gt;9 &amp;gt;&amp;gt;&amp;gt; 2&lt;/code&gt; 得到 2 和 &lt;code&gt;9 &amp;gt;&amp;gt; 2&lt;/code&gt; 相同。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;js 中位运算符的妙用&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;使用&amp;amp;运算符判断数字的奇偶性&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// even &amp;amp; 1 = 0\n// odd &amp;amp; 1 = 1\nconsole.log(2 &amp;amp; 1); // 0\nconsole.log(3 &amp;amp; 1); // 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;使用 &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt; 来舍入&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;console.log(~~6.83); // 6\nconsole.log(6.83 &amp;gt;&amp;gt; 0); // 6\nconsole.log(6.83 &amp;lt;&amp;lt; 0); // 6\nconsole.log(6.83 | 0); // 6\n// &amp;gt;&amp;gt;&amp;gt; cannot round negative numbers\nconsole.log(6.83 &amp;gt;&amp;gt;&amp;gt; 0); // 6\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;使用 ^ 完成值交换&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var a = 5;\nvar b = 8;\na ^= b;\nb ^= a;\na ^= b;\nconsole.log(a); // 8\nconsole.log(b); // 5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;使用 &lt;code&gt;&amp;amp;&lt;/code&gt;、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;|&lt;/code&gt; 完成 rgb 值与十六进制颜色值之间的转换&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;/**\n * Hexadecimal color value to RGB\n * @param {String} hex hexadecimal color string\n * @return {String} RGB color string\n */\nfunction hexToRGB(hex) {\n  var hexx = hex.replace(&amp;quot;#&amp;quot;, &amp;quot;0x&amp;quot;);\n  var r = hexx &amp;gt;&amp;gt; 16;\n  var g = (hexx &amp;gt;&amp;gt; 8) &amp;amp; 0xff;\n  var b = hexx &amp;amp; 0xff;\n  return `rgb(${r}, ${g}, ${b})`;\n}\n\n/**\n * RGB color to hexadecimal color\n * @param {String} rgb RGB color string\n * @return {String} Hexadecimal color string\n */\nfunction RGBToHex(rgb) {\n  var rgbArr = rgb.split(/[^\\d]+/);\n  var color = (rgbArr[1] &amp;lt;&amp;lt; 16) | (rgbArr[2] &amp;lt;&amp;lt; 8) | rgbArr[3];\n  return &amp;quot;#&amp;quot; + color.toString(16);\n}\n// ------------------------------------------------ -\nhexToRGB(&amp;quot;#ffffff&amp;quot;); // &amp;#39;rgb(255,255,255)&amp;#39;\nRGBToHex(&amp;quot;rgb(255,255,255)&amp;quot;); // &amp;#39;#ffffff&amp;#39;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;
}</pre
    >
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/loader.js"></script>
    <script src="./js/edit.js"></script>
  </body>
</html>
